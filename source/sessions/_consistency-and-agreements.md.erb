In a monolith, achieving consistency is easy - just use a transaction! In a distributed world, where we mix legacy and greenfield, getting systems to agree becomes quite a bit more complex. We have different databases, different communication methods, caches, and more. How can we get anything to agree on the state of anything?

In this session, we'll look at how to implement various consistency and transactional patterns, to support both real-time and async updates. We'll also look at long-running transaction patterns such as sagas to manage agreements between systems. Finally, we'll look at a full working example that crosses databases, APIs, messaging, and more.